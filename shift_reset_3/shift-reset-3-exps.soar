#
#increment(X) :- !,
#  X = lam(x, succ(var(x))).
#
#true(X) :- !,
#  X = lam(truebranch, lam(falsebranch, var(truebranch))).
#
#false(X) :- !,
#  X = lam(truebranch, lam(falsebranch, var(falsebranch))).
#
# y(X) :- !, yhelper(H),
#   X = lam(f, app(H, H)).
# yhelper(X) :- !,
#   X = lam(x, app(var(f), lam(v, app(app(var(x), var(x)), var(v))))).
# 
# There shouldn't be any problem with sharing. I hope.
#
sp {apply*create-yhelper
  (state <s> ^operator <o>)
  (<o> ^name create-y ^return-to <r>)
-->
  (<s> ^<r> <ycombinator>)
  (<ycombinator> ^lam <l1>)
  (<l1> ^name <f> ^exp <a2>)
  (<a2> ^major <yhelper> ^minor <yhelper>) 
  (<yhelper> ^lam <l3>)
  (<l3> ^name <x> ^exp.app <a4>)
  (<a4> ^major.var <f> ^minor.lam <l5>)
  (<l5> ^name <v> ^exp.app <a6>)
  (<a6> ^major.app <a7> ^minor.var <v>)
  (<a7> ^major.var <x> ^minor.var <x>)}

#emitloop(X) :- !, y(Y), emitloopbody(Body),
#  X = app(Y, Body).
#emitloopbody(X) :- !,
#  X = lam(f, lam(x, ifzero(var(x), int(1), app(lam(y, app(var(f), pred(var(x)))), emit(var(c)))))).
#emitblock(X) :- !, emitloop(Loop),
#  X = app(lam(len, app(lam(c, app(Loop, var(len))), getchar)), getchar).

#decompressbody(X) :- !, emitblock(EMITBLOCK),
#  X = lam(rest, lam(notdone, ifzero(var(notdone),
#    app(lam(x, int(1)), emit(int(0))),
#    app(lam(c, 
#    app(rest, ifzero(var(c), int(0), ifzero(minus(var(c), int(123)), app(lam(x, int(1)), EMITBLOCK), app(lam(x,# int(1)), emit(var(c))))))), getchar)))).

#dim(X) :- !, y(Y),
#  X = app(Y, lam(recursefun, lam(x, lam(y, ifzero(var(y), var(x), ifzero(var(x), var(x), 
#    app(app(var(recursefun), pred(var(x))), pred(var(y))))))))).

#% technically this tests for between A and Z in ascii representation,
#% not 'alpha' which should at least include lowercase.
#isalpha(X) :- !, dim(D),
#  X = lam(c, ifzero(app(app(D, int(65)), var(c)),
#    ifzero(app(app(D, var(c)), int(90)), int(1), int(0)), int(0))).

#% restofword is supposed to take a character,
#% and keep getting new characters and emitting them so long as they're alphabetic
#% until it finds a nonalphabetic character. Then it emits a 119 ('w') to indicate 'word'
#% and stops. It's a helper for parser, not a thing in itself.
#restofword(X) :- !, isalpha(ISALPHA), y(Y),
#X = app(Y, lam(recursefun2,
#      lam(c,
#        app(lam(ignored,
#          app(lam(d,
#            ifzero(app(ISALPHA, var(d)),
#              app(lam(ignored,
#                app(lam(ignored,
#                  app(var(recursefun), getchar)
#                ), emit(int(119)))
#              ), emit(var(d))),
#              app(var(recursefun2), var(d)))
#          ), getchar)
#        ), emit(var(c)))))).

#% this "parser" (actually more like a lexer?) reads numbers until it sees a sentinel (123),
#% and classifies them into contiguous sequences of uppercase alpha (A-Z) 
#% or a single character of anything else by suffixing them with 119 ('w') for 'word'
#% or 112 'p' for 'punctuation'.
#parser(X) :- !, isalpha(ISALPHA), y(Y), restofword(RESTOFWORD),
#X = app(Y, lam(recursefun, 
#     lam(c, 
#       ifzero(minus(var(c), int(123)),
#         int(1),
#         ifzero(app(ISALPHA, var(c)),
#           app(lam(ignored,
#             app(lam(ignored,
#               app(var(recursefun), getchar)
#             ), emit(int(112)))
#           ), emit(var(c))),
#	   app(RESTOFWORD, var(c))
#     ))))).

#% requests are a data structure
#% requests include exit, read, and write
#% exit contains no continuation
#% read contains a continuation that that accepts a character,
#% yields anther request (usually exit)
#% and may issue more requests.
#% " a continuation that accepts a character and yields another request"
#% might look like app(lam(ignored, emit([char])), shift(k, Exit))
#% app(lam(ignored, emit(shift(k, Read(k)))), Exit)
#% write contains a character to write,
#% and a continuation that accepts nothing.
#% service(req) == shift(k, app(var(req), var(k)))
#service(X) :- !,
#  X = lam(req, shift(k, app(var(req), var(k)))).

#% datatype Req = Exit | Read(k) | Write(char, k)
#% a reqconsumer needs three branches
#% I think this is the Scott encoding?
#reqexit(X) :- !,
#  X = lam(k, lam(e, lam(r, lam(w, var(e))))).
#reqread(X) :- !,
#  X = lam(k, lam(e, lam(r, lam(w, app(var(r), var(k)))))).
#reqwrite(X) :- !,
#  X = lam(c, lam(k, lam(e, lam(r, lam(w, 
#    app(app(var(w), var(c)), var(k))))))).

#% cat2 is a process
#% cat2 reads a character, writes it, reads another character, writes it, and then exits.
#cat2(X) :- !, reqread(Read), reqwrite(Write), reqexit(Exit), service(Service),
#  X = app(lam(c,
#        app(lam(ignored,
#          app(lam(d,
#            app(lam(ignored,
#              app(Service, Exit)
#            ), app(Service, app(Write, var(d))))
#          ), app(Service, Read))
#        ), app(Service, app(Write, var(c))))
#      ), app(Service, Read)).

#% cat is a process, you read it something like:
#% fixpoint of lam(recurse, 
#%   let input = service Read in
#%   let _ = service (Write input) in
#%   recurse
#cat(X) :- !, reqread(Read), reqwrite(Write), service(Service), y(Y),
#  X = app(Y, lam(recurse,
#      app(lam(input, 
#        app(lam(ignored, 
#          var(recurse)
#        ), app(Service, app(Write, var(input))))
#      ), app(Service, Read)))).

#% catuntil is a process
#% catuntil copies to input to output until it sees a sentinel value (123)
#% it's something like:
#% let rec catuntil input = 
#%   if input == 123 then
#%     service Exit
#%   else
#%     let _ = service (Write input) in
#%       recurse (service Read)
#catuntil(X) :- !, reqread(Read), reqwrite(Write), reqexit(Exit), service(Service), y(Y),
#  X = app(Y, lam(recurse, lam(input, 
#        ifzero(minus(var(input), int(123)),
#          app(Service, Exit),
#          app(lam(ignored, 
#            app(var(recurse), app(Service, Read))
#          ), app(Service, app(Write, var(input))))
#        )
#      ))).

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#% This is the previous "parser" rewritten as a process
#% We replace 'getchar' with app(Service, Read)
#% and emit(foo) with app(Service, app(Write, foo))
#%
#% The parser process can be run on its own like so:
#%
#% parser_service(Parser), interpret(Interpret),
#% run(app(Interpret, reset(app(Parser, getchar))), Answer).
#
#restofword_service(X) :- !, isalpha(ISALPHA), y(Y), service(Service), reqread(Read), reqwrite(Write),
#  X = app(Y, lam(recursefun2,
#        lam(c,
#          app(lam(ignored,
#            app(lam(d,
#              ifzero(app(ISALPHA, var(d)),
#                app(lam(ignored,
#                  app(lam(ignored,
#                    app(var(recursefun), app(Service, Read))
#                  ), app(Service, app(Write, int(119))))
#                ), app(Service, app(Write, var(d)))),
#                app(var(recursefun2), var(d)))
#            ), app(Service, Read))
#          ), app(Service, app(Write, var(c))))))).

#parser_service(X) :- !,
#  isalpha(ISALPHA), y(Y), restofword_service(RESTOFWORD),
#  service(Service), reqread(Read), reqwrite(Write), reqexit(Exit),
#  X = app(Y, lam(recursefun, 
#       lam(c, 
#         ifzero(minus(var(c), int(123)),
#           app(Service, Exit),
#           ifzero(app(ISALPHA, var(c)),
#             app(lam(ignored,
#               app(lam(ignored,
#                 app(var(recursefun), app(Service, Read))
#               ), app(Service, app(Write, int(112))))
#             ), app(Service, app(Write, var(c)))),
#  	   app(RESTOFWORD, var(c))
#       ))))).

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#% This is the decompressor process.
#%
#% It does something like run length decompression,
#% with 123 as a sentinel value, so a run of 4 3s is coded as 123 4 3
#% and a literal 123 is coded as 123 1 123
#%
#% The decompressor process can be run on its own like so:
#%
#% decompress_service(Decompress), interpret(Interpret),
#% run(app(Interpret, reset(app(Decompress, getchar))), Answer).
#
#emitblock_service(X) :- !, y(Y), service(Service), reqread(Read), reqwrite(Write),
#  X = app(lam(len, app(lam(c, app(app(Y, lam(f, lam(x, ifzero(var(x), int(1), app(lam(y, app(var(f), pred(var(x#)))), app(Service, app(Write, var(c)))))))), var(len))), app(Service, Read))), app(Service, Read)).

#decompress_service(X) :- !, 
#  y(Y), emitblock_service(BLOCK), service(Service), reqread(Read), reqwrite(Write), reqexit(Exit),
#  X = app(Y, lam(f, lam(x, ifzero(var(x), app(Service, Exit),
#  	ifzero(minus(var(x), int(123)), 
#  	app(lam(y, app(var(f), app(Service, Read))), BLOCK),
#  	app(lam(y, app(var(f), app(Service, Read))), app(Service, app(Write, var(x))))))))).
#
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#% interpret lets you run a single process
#%
#% It obeys requests to exit, read, or write,
#% and then immediately resumes the computation (for read and write, obviously not exit).
#interpret(X) :- !, y(Y),
#  X = app(Y, lam(recurse, lam(to_interpret, 
#    app(app(app(var(to_interpret), 
#  	int(1)), % exit 
#  	lam(k, app(var(recurse), reset(app(var(k), getchar))))), % read
#  	lam(c, lam(k, app(var(recurse), reset(app(var(k), emit(var(c))))))))))). % write

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
#% This is the "operating system" section
#% it's not much of an operating system,
#% just a pipe between a producer (the "former") and a consumer (the "latter")
#%
#% Oleg Kiselyov was able to write something like an operating system (ZipperFS)
#% in 500 lines of Haskell. I am not Oleg Kiselyov.
#%
#% You can pipe the decompression service 
#% parser_service(Parser), decompress_service(Decompress), pipe(Pipe),
#% run(app(app(Pipe, reset(app(Decompress, getchar))), Parser), Answer).
#
#% writeblock is a helper for pipe - it pumps the "latter" process,
#% emitting as many characters as possible.
#writeblock(X) :- !, y(Y), 
#  X = app(Y, lam(recurse2, lam(former2, lam(latter2,
#    app(app(app(var(latter2),
#  	int(1)), % latter exits - whole thing exits
#        lam(k, app(app(var(recurse), reset(app(var(former2), int(1)))), var(k)))), % read from former
#  	lam(c, lam(k, app(app(var(recurse2), var(former2)), reset(app(var(k), emit(var(c)))))))) % write
#)))).

#% pipe is like interpret for two processes
#% it implements read and write differently for the two processes
#% the first process reads via getchar, and writes into the second process
#% the second process emits and reads from the first process.
#pipe(X) :- !, y(Y), writeblock(Writeblock),
#  X = app(Y, lam(recurse, lam(former, lam(latter,
#    app(app(app(var(former),
#  	int(1)), % former exits - whole thing exits
#        lam(k, app(app(var(recurse), reset(app(var(k), getchar))), var(latter)))), % former reads - getchar
#        lam(c, lam(k, app(app(Writeblock, var(k)), reset(app(var(latter), var(c))))))) % pipe to latter
#)))).

