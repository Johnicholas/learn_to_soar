# This is a register machine ish interpreter,
# for a lambda calculus with shift and reset,
# based on reading several papers, but particularly
# Oleg Kiselyov and Chung-chih Shan's papers.
#
# This is probably terrible Soar style.

# registers:
#   name -- stores the name of the current state of the machine
#   exp -- stores the current expression
#   env -- stores the current environment (an association list)
#   cont -- stores the current continuation
#   value -- stores the current value
#   key -- stores the name we're looking up when we're looking up
#
# operators:
#   run -- run an expression. returns a value in ^run-done

#################################### run
sp {run*initialize
  (state <s> ^superstate.operator <o>)
  (<o> ^name run ^exp <e> ^return-to <r>)
-->
  (<s> ^name run ^exp <e> ^return-to <r>)}

# if
#   name is run
# then
#   change name to step and
#   (keep exp the same and)
#   set env to empty and
#   set cont to hole
#
# go(run, Exp, _Env, _Cont, _Value, _Key, Out) :- !,
#   % print('run'), nl, backtrace(5),
#   go(step, Exp, empty, hole, _, _, Out). # tail call
sp {run*propose*start
  (state <s> ^name run)
-->
  (<s> ^operator <o> +)
  (<o> ^name start)}

sp {run*apply*start
  (state <s> ^name run ^operator.name start)
-->
  (<s> ^name run - step ^env empty ^cont hole)}


# if
#   name is step and
#   exp is an int
# then
#   change name to cont and
#   reject exp and
#   reject env and
#   (keep cont the same and)
#   set value to int's body
#
# go(step, int(N), _Env, Cont, _Value, _Key, Out) :- !,
#   % print('step*int'), nl, backtrace(5),
#   go(cont, _, _, Cont, N, _, Out). # tail call
sp {step*propose*stepint
  (state <s> ^name step ^exp.int)
-->
  (<s> ^operator <o> +)
  (<o> ^name stepint)}

sp {step*apply*stepint
  (state <s> ^name step ^operator.name stepint ^exp <exp> ^env <env>)
  (<exp> ^int <N>)
-->
  (<s> ^name step - cont ^exp <exp> - ^env <env> - ^value <N>)}

# if
#   name is step and
#   exp is a var
# then
#   change name to lookup and
#   reject exp and
#   (keep env the same and)
#   (keep cont the same and)
#   set key to var's body
#
# go(step, var(K), Env, Cont, _Value, _Key, Out) :- !,
#   % print('step*var'), nl, backtrace(5),
#   go(lookup, _, Env, Cont, _, K, Out). # tail call
sp {step*propose*stepvar
  (state <s> ^name step ^exp.var)
-->
  (<s> ^operator <o> +)
  (<o> ^name stepvar)}

sp {step*apply*stepvar
  (state <s> ^name step ^operator.name stepvar ^exp <exp> ^env <env>)
  (<exp> ^var <X>)
-->
  (<s> ^name step - lookup ^exp <exp> - ^key <X>)}

# if
#   name is step and
#   exp is a lam
# then
#   change name to cont and
#   reject exp and
#   reject env and
#   (keep cont the same and)
#   set value to a newly built closure of lam's key, lam's exp, and env
#
# go(step, lam(X, Exp), Env, Cont, _Value, _Key, Out) :- !,
#   % print('step*lam'), nl, backtrace(5),
#   go(cont, _, _, Cont, clo(X, Exp, Env), _, Out). # tail call
sp {step*propose*steplam
  (state <s> ^name step ^exp.lam)
-->
  (<s> ^operator <o> +)
  (<o> ^name steplam)}

sp {step*apply*steplam
  (state <s> ^name step ^operator.name steplam ^exp <exp> ^env <env>)
  (<exp> ^lam <lam>)
  (<lam> ^key <x> ^exp <body>)
-->
  (<s> ^name step - cont ^exp <exp> - ^env <env> - ^value.clo <clo>)
  (<clo> ^key <x> ^exp <body> ^env <env>)}

# if
#   name is step and
#   exp is an app
# then
#   change exp to app's major and
#   (keep env the same and)
#   change cont to a newly built appK1 of app's minor, env, and cont
#
# go(step, app(Major, Minor), Env, Cont, _Value, _Key, Out) :- !,
#   % print('step*app'), nl, backtrace(5),
#   go(step, Major, Env, appK1(Minor, Env, Cont), _, _, Out). # tail call
sp {step*propose*stepapp
  (state <s> ^name step ^exp.app)
-->
  (<s> ^operator <o> +)
  (<o> ^name stepapp)}

sp {step*apply*stepapp
  (state <s> ^name step ^operator.name stepapp ^exp <exp> ^env <env> ^cont <k>)
  (<exp> ^app <app>)
  (<app> ^major <newexp> ^minor <minor>)
-->
  (<s> ^exp <exp> - <newexp> ^cont <k> - <newk>)
  (<newk> ^appK1 <appK1>)
  (<appK1> ^exp <minor> ^env <env> ^cont <k>)}

# if
#   name is step and
#   exp is a succ
# then
#   change exp to succ's exp
#   change cont to a newly built succK of cont
# go(step, succ(Exp), Env, Cont, _Value, _Key, Out) :- !,
#   % print('step*succ'), nl, backtrace(5),
#   go(step, Exp, Env, succK(Cont), _, _, Out). # tail call
sp {step*propose*stepsucc
  (state <s> ^name step ^exp.succ)
-->
  (<s> ^operator <o> +)
  (<o> ^name stepsucc)}

sp {step*apply*stepsucc
  (state <s> ^name step ^operator.name stepsucc ^exp <exp> ^cont <k>)
  (<exp> ^succ.exp <newexp>)
-->
  (<s> ^exp <exp> - <newexp> ^cont <k> - <newk>)
  (<newk> ^succK.cont <k>)}

# if
#   name is step and
#   exp is a shift
# then
#   change exp to shift's exp
#   change cont to hole
#   change env to a newly built bind of shift's key, a newly built cap of cont, and env
# go(step, shift(K, Exp), Env, Cont, _Value, _Key, Out) :- !,
#   % print('step*shift'), nl, backtrace(5),
#   go(step, Exp, bind(K, cap(Cont), Env), hole, _, _, Out). # tail call
sp {step*propose*stepshift
  (state <s> ^name step ^exp.shift)
-->
  (<s> ^operator <o> +)
  (<o> ^name stepshift)}

sp {step*apply*stepshift
  (state <s> ^name step ^operator.name stepshift ^exp <exp> ^cont <k> ^env <env>)
  (<exp> ^shift <shift>)
  (<shift> ^exp <newexp> ^key <key>)
-->
  (<s> ^exp <exp> - <newexp> ^cont <k> - hole ^env <env> - ^env.bind <bind>)
  (<bind> ^key <key> ^value.cap <k> ^env <env>)}

# if
#   name is step and
#   exp is a reset
# then
#   first
#     run recursively reset's exp
#   then
#     change step to cont
#     reject exp and
#     reject env and
#     set value to Temp
# go(step, reset(Exp), Env, Cont, _Value, _Key, Out) :- !,
#   % print('step*reset'), nl, backtrace(5),
#   go(step, Exp, Env, hole, _, _, Temp), # not a tail call, pushes onto stack
#   go(cont, _, _, Cont, Temp, _, Out). # tail call
sp {step*propose*run
  (state <s> ^name step ^exp.reset.exp <exp> -^run-done)
-->
  (<s> ^operator <o> +)
  (<o> ^name run ^exp <exp> ^return-to <s>)}

sp {step*propose*stepreset2
  (state <s> ^name step ^exp.reset ^run-done)
-->
  (<s> ^operator <o> +)
  (<o> ^name stepreset2)}

sp {step*apply*stepreset2
  (state <s> ^name step ^operator.name stepreset2
    ^exp <exp>
    ^env <env> 
    ^run-done <Temp>)
-->
  (<s> ^name step - cont
    ^exp <exp> -
    ^env <env> -
    ^run-done <Temp> -
    ^value <Temp>)}

# if
#   name is lookup and
#   env is a bind and
#   key matches bind's key
# then
#   change name to cont
#   reject env
#   reject key
#   set value to bind's value
#
# go(lookup, _Exp, bind(K, V, _Env), Cont, _Value, K, Out) :- !,
#   % print('lookup*found'), nl, backtrace(5),
#   go(cont, _, _, Cont, V, _, Out). # tail call
sp {lookup*propose*lookupfound
  (state <s> ^name lookup ^env.bind.key <k> ^key <k>)
-->
  (<s> ^operator <o> +)
  (<o> ^name lookupfound)}

sp {lookup*apply*lookupfound
  (state <s> ^name lookup ^operator.name lookupfound ^env <env> ^key <key>)
  (<env> ^bind.value <value>)
-->
  (<s> ^name lookup - cont ^env <env> - ^key <key> - ^value <value>)}

# if
#   name is lookup and
#   env is a bind and
#   key doesn't match bind's key
# then
#   change env to bind's Env
#
# go(lookup, _Exp, bind(K1, _V, Env), Cont, _Value, K2, Out) :- K1 \= K2, !,
#   % print('lookup*not-found'), nl, backtrace(5),
#   go(lookup, _, Env, Cont, _, K2, Out). # tail call
sp {lookup*propose*lookupnotfound
  (state <s> ^name lookup ^env.bind.key <k1> ^key <k2> <> <k1>)
-->
  (<s> ^operator <o> +)
  (<o> ^name lookupnotfound)}

sp {lookup*apply*lookupnotfound
  (state <s> ^name lookup ^operator.name lookupnotfound ^env <env>)
  (<env> ^bind.env <newenv>)
-->
  (<s> ^env <env> - <newenv>)}
 
# if
#   name is cont and
#   cont is hole
# then
#   return value
#
# go(cont, _Exp, _Env, hole, Value, _Key, Out) :- !,
#   % print('cont*hole'), nl, backtrace(5),
#   Out = Value. # return, reducing size of stack
sp {cont*propose*conthole
  (state <s> ^name cont ^cont hole)
-->
  (<s> ^operator <o> +)
  (<o> ^name conthole)}

sp {cont*apply*conthole
  (state <s> ^name cont ^operator.name conthole ^superstate <ss> ^value <v>)
-->
  (<ss> ^run-done <v>)}

# if
#   name is cont and
#   cont is a appK1
# then
#   change name to step
#   reject value
#   set exp to appK1's exp
#   set env to appK1's env
#   change cont to a newly built appK2 with value and cont
#
# go(cont, _Exp, _Env, appK1(Exp, Env, Cont), Value, _Key, Out) :- !,
#   % print('cont*appK1'), nl, backtrace(5),
#   go(step, Exp, Env, appK2(Value, Cont), _, _, Out). # tail call
sp {cont*propose*contappK1
  (state <s> ^name cont ^cont.appK1)
-->
  (<s> ^operator <o> +)
  (<o> ^name contappK1)}

sp {cont*apply*contappK1
  (state <s> ^name cont ^operator.name contappK1 ^value <v> ^cont <k>)
  (<k> ^appK1 <appK1>)
  (<appK1> ^exp <exp> ^env <env> ^cont <later>)
-->
  (<s> ^name cont - step ^value <v> - ^exp <exp> ^env <env> ^cont <k> - <newk>)
  (<newk> ^appK2 <appK2>)
  (<appK2> ^value <v> ^cont <later>)}

# if
#   name is cont and
#   cont is an appK2 of a closure
# then
#   change name to step
#   set exp to appK2's closure's Exp
#   reject value
#   set env to a newly built bind with appK2's closure's key, value, and appK2's closure's env
#   change cont to appK2's cont
#
# go(cont, _Exp, _Env, appK2(clo(X, Exp, Env), Cont), Value, _Key, Out) :- !,
#   % print('cont*appK2*clo'), nl, backtrace(5),
#   go(step, Exp, bind(X, Value, Env), Cont, _, _, Out). # tail call
sp {cont*propose*contappK2clo
  (state <s> ^name cont ^cont.appK2.value.clo)
-->
  (<s> ^operator <o> +)
  (<o> ^name contappK2clo)}

sp {cont*apply*contappK2clo
  (state <s> ^name cont ^operator.name contappK2clo ^cont.appK2 <appK2> ^value <v> ^cont <k>)
  (<appK2> ^value.clo <clo> ^cont <newk>)
  (<clo> ^key <x> ^exp <exp> ^env <env>)
-->
  (<s> ^name cont - step ^exp <exp> ^value <v> - ^env.bind <bind> ^cont <k> - <newk>)
  (<bind> ^key <x> ^value <v> ^env <env>)}

# if
#   name is cont and
#   cont is a appK2 of a capture
# then
#   first
#     call cont recursively with the captured continuation
#   then
#     change cont to the appK2's cont and
#     change value to the result of temp
#
# go(cont, _Exp, _Env, appK2(cap(ContPrime), Cont), Value, _Key, Out) :- !,
#   % print('cont*appK2*cap'), nl, backtrace(5),
#   go(cont, _, _, ContPrime, Value, _, Temp), # not a tail call, pushes onto the Prolog architectural stack
#   go(cont, _, _, Cont, Temp, _, Out). # tail call
sp {cont*appK2*propose*cont
  (state <s> ^name cont ^cont.appK2.value.cap <k> -^run-done ^value <v>)
-->
  (<s> ^operator <o> +)
  (<o> ^name cont ^cont <k> ^value <v> ^return-to <s>)}

sp {cont*initialize
  (state <s> ^superstate.operator <o>)
  (<o> ^name cont ^cont <k> ^value <v> ^return-to <r>)
-->
  (<s> ^name cont ^cont <k> ^value <v> ^return-to <r>)}

sp {cont*appK2*propose*contappK2cap
  (state <s> ^name cont ^cont.appK2.value.cap ^run-done)
-->
  (<s> ^operator <o> +)
  (<o> ^name contappK2cap)}

sp {cont*apply*contappK2cap
  (state <s> ^name cont ^operator.name contappK2cap ^cont <k> ^value <v> ^run-done <newv>)
  (<k> ^appK2.cont <newk>)
-->
  (<s> ^cont <k> - <newk> ^value <v> - <newv> ^run-done <newv> -)}

# if
#   name is cont and
#   cont is a succK
# then
#   increment value
#   set cont to succK's cont
#
# go(cont, _Exp, _Env, succK(Cont), N, _Key, Out) :- !,
#   % print('cont*succK'), nl, backtrace(5),
#   M is N + 1,
#   go(cont, _, _, Cont, M, _, Out). # tail call
sp {cont*propose*contsuccK
  (state <s> ^name cont ^cont.succK)
-->
  (<s> ^operator <o> +)
  (<o> ^name contsuccK)}

sp {cont*apply*contsuccK
  (state <s> ^name cont ^operator.name contsuccK ^value <N> ^cont <k>)
  (<k> ^succK.cont <newk>)
-->
  (<s> ^value <N> - (+ <N> 1) ^cont <k> - <newk>)}

