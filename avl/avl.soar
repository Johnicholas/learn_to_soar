# This is an attempt at implementing AVL trees in Soar.
# It is based on avltree.pure, but probably bugs were introduced by Johnicholas
#
# ASSUMPTIONS
#
# less-than is an operator, provided by the client, that compares two elements
#
# PUBLIC 
#
# empty-set builds a new empty set
#
# insert takes an element <to-insert> and a set and builds a new set that includes <to-insert>.
# if <to-insert> or something that (according to less-than) compares equal to <to-insert> is already in the set,
# then the set doesn't change.
#
# delete takes an element <to-delete> and a set and builds a new set without <to-delete>
# 
# lookup takes an element <key> and a set and returns either nothing,
# or ^just <x>, where <x> is the element from the set that compares equal to the key
#
# PRIVATE
#
# makenode - a smart constructor that takes a node, a left tree and a right tree,
# and allocates a new node making sure to set its height field correctly.
#
# height - the height of an empty tree is zero; other trees have a height field that should be trusted.
#
# slope - the slope of an empty tree is zero;
# otherwise its the difference between heights of the left and right subtrees
#
# avl - a smart constructor that takes a node, a left tree and a right tree,
# and builds a new tree satisfying the AVL invariant.
#
# rebalance - takes a slightly-unbalanced tree and fixes it, by delegating to shiftleft or shiftright,
# or returning the input if it isn't actually unbalanced.
#
# rollleft - an operator that takes apart a right-leaning tree and builds a more-balanced tree
#
# rollright - an operator that takes apart a left-leaning tree and builds a more-balanced tree
#
# shiftleft - an operator used by rebalance and delegating to rollleft and rollright to fix up a nearly-balanced tree
#
# shiftright - an operator used by rebalance and delegating to rollright to fix up a nearly-balanced tree
#
# join - an operator that takes a left avl tree and a right avl tree and builds a combination tree
#
# last - an operator used (by join) to find the last of an avl tree; you must call it with an element and a tree,
# it will return the element you called it with, or the last of the avl tree.
#
# init - an operator used (by join) to find the initial segment of an avl tree; all but the last element.
#
# REPRESENTATION
#
# An avl set is always ^Avl <x>, where <x> is a tree
# A tree is either nil or a node.
# Nodes are augmented with ^height <h> where <h> is a number, ^element <e>, where <e> is whatever the client
# is storing in this set, and both ^left <l> and ^right <r> where <l> and <r> are trees.
#
# The invariant maintained is simple: the heights are correct, and the subtrees differ in height by no more than 1.

sp {empty-set*apply
    (state <s> ^operator <o>)
    (<o> ^name empty-set ^return-to <return-to>)
-->
    (<s> ^<return-to>.Avl nil)}

######################################### delete

sp {delete*initialize*initially
    (state <s> ^superstate.operator <o>)
    (<o> ^name delete ^element <e> ^set.Avl <t> ^return-to <r>)
-->
    (<s> ^name delete ^element <e> ^tree <t> ^return-to <r>)}

sp {delete*propose*delete-tree
    (state <s> ^name delete ^element <e> ^tree <t> -^delete-tree-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name delete-tree ^element <e> ^tree <t> ^return-to delete-tree-result)}

sp {delete*copy*upward
    (state <s> ^name delete ^superstate <ss> ^return-to <return-to> ^delete-tree-result <answer>)
-->
    (<ss> ^<return-to>.Avl <answer>)}

########################################## delete-tree

sp {delete-tree*initialize
    (state <s> ^superstate.operator <o>)
    (<o> ^name delete-tree ^element <e> ^tree <t> ^return-to <r>)
-->
    (<s> ^name delete-tree ^element <e> ^tree <t> ^return-to <r>)}

sp {delete-tree*apply*nil
    (state <s> ^name delete-tree ^tree nil ^superstate <ss> ^return-to <r>)
-->
    (<ss> ^<r> nil)}

sp {delete-tree*propose*check-left
    (state <s> ^name delete-tree ^tree.element <x> ^element <y> -^check-left-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <x> ^right <y> ^return-to check-left-result)}

sp {delete-tree*propose*check-right
    (state <s> ^name delete-tree ^check-left-result false ^tree.element <x> ^element <y> -^check-right-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <y> ^right <x> ^return-to check-right-result)}

sp {delete-tree*propose*recurse-left
    (state <s> ^name delete-tree ^check-left-result true ^tree.left <t> ^element <y> -^recurse-left-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name delete-tree ^tree <t> ^element <y> ^return-to recurse-left-result)}

sp {delete-tree*recurse-left-done*propose*avl
    (state <s> ^name delete-tree ^tree <t> ^recurse-left-result <a> -^avl-result)
    (<t> ^element <x> ^right <r>)
-->
    (<s> ^operator <o> +)
    (<o> ^name avl ^element <x> ^left <a> ^right <r> ^return-to answer)}

sp {delete-tree*propose*recurse-right
    (state <s> ^name delete-tree ^check-right-result true ^tree.right <t> ^element <y> -^recurse-right-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name delete-tree ^tree <t> ^element <y> ^return-to recurse-right-result)}

sp {delete-tree*recurse-right-done*propose*avl
    (state <s> ^name delete-tree ^tree <t> ^recurse-right-result <a> -^avl-result)
    (<t> ^element <x> ^left <l>)
-->
    (<s> ^operator <o> +)
    (<o> ^name avl ^element <x> ^left <l> ^right <a> ^return-to answer)}

sp {delete-tree*found-here*propose*join
    (state <s> ^name delete-tree
               ^check-left-result false
               ^check-right-result false
               ^tree <t>
              -^join-result)
    (<t> ^left <l> ^right <r>)
-->
    (<s> ^operator <o> +)
    (<o> ^name join ^left <l> ^right <r> ^return-to answer)}

sp {delete-tree*copy-answer-upward
    (state <s> ^name delete-tree ^superstate <ss> ^return-to <r> ^answer <a>)
-->
    (<ss> ^<r> <a>)}

##################### lookup


sp {lookup*initialize*initially
    (state <s> ^superstate.operator <o>)
    (<o> ^name lookup ^element <e> ^set.Avl <t> ^return-to <r>)
-->
    (<s> ^name lookup ^element <e> ^tree <t> ^return-to <r>)}

sp {lookup*initialize*recursively
    (state <s> ^superstate.operator <o>)
    (<o> ^name lookup ^element <e> ^tree <t> ^return-to <r>)
-->
    (<s> ^name lookup ^element <e> ^tree <t> ^return-to <r>)}

sp {lookup*apply*nil
    (state <s> ^name lookup ^tree nil ^superstate <ss> ^return-to <r>)
-->
    (<ss> ^<r> nothing)}

sp {lookup*propose*check-left
    (state <s> ^name lookup ^tree.element <x> ^element <y> -^check-left-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <x> ^right <y> ^return-to check-left-result)}

sp {lookup*propose*check-right
    (state <s> ^name lookup ^check-left-result false ^tree.element <x> ^element <y> -^check-right-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <y> ^right <x> ^return-to check-right-result)}

sp {lookup*propose*recurse-left
    (state <s> ^name lookup ^check-left-result true ^tree.left <t> ^element <y> -^recursion-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name lookup ^tree <t> ^element <y> ^return-to recursion-result)}

sp {lookup*apply*recursion-done
    (state <s> ^name lookup ^superstate <ss> ^return-to <r> ^recursion-result <a>)
-->
    (<ss> ^<r> <a>)}

sp {lookup*propose*recurse-right
    (state <s> ^name lookup ^check-right-result true ^tree.right <t> ^element <y> -^recursion-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name lookup ^tree <t> ^element <y> ^return-to recursion-result)}

sp {lookup*apply*found-here
    (state <s> ^name lookup ^check-left-result false ^check-right-result false
               ^superstate <ss> ^return-to <r> ^tree.element <x>)
-->
    (<ss> ^<r>.just <x>)}

##################################### insert

sp {insert*initialize
    (state <s> ^superstate.operator <o>)
     (<o> ^name insert ^element <e> ^set.Avl <t> ^return-to <r>)
-->
    (<s> ^name insert ^element <e> ^tree <t> ^return-to <r>)}

sp {insert*propose*insert-tree
    (state <s> ^name insert ^element <e> ^tree <t> -^insert-tree-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name insert-tree ^element <e> ^tree <t> ^return-to insert-tree-result)}

sp {insert*copy*upward
    (state <s> ^name insert ^superstate <ss> ^return-to <r> ^insert-tree-result <a>)
-->
    (<ss> ^<r>.Avl <a>)}

########################## insert-tree

sp {insert-tree*initialize
    (state <s> ^superstate.operator <o>)
    (<o> ^name insert-tree ^element <e> ^tree <t> ^return-to <r>)
-->
    (<s> ^name insert-tree ^element <e> ^tree <t> ^return-to <r>)}

sp {insert-tree*nil
    (state <s> ^name insert-tree ^element <y> ^tree nil ^superstate <ss> ^return-to <r>)
-->
    (<ss> ^<r> <newnode>)
    (<newnode> ^height 1 ^element <y> ^left nil ^right nil)}

sp {insert-tree*propose*check-left
    (state <s> ^name insert-tree ^element <y> ^tree <t> -^check-left-result)
    (<t> ^element <x>)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <x> ^right <y> ^return-to check-left-result)}

sp {insert-tree*propose*check-right
    (state <s> ^name insert-tree ^element <y> ^tree <t> ^check-left-result false -^check-right-result)
    (<t> ^element <x>)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <y> ^right <x> ^return-to check-right-result)}

sp {insert-tree*apply*equal
    (state <s> ^name insert-tree
               ^check-left-result false
               ^check-right-result false
               ^superstate <ss> ^return-to <r> ^tree <a>)
-->
    (<ss> ^<r> <a>)}

# TODO: check-left-result true
# TODO: check-right-result true

################################ join 

sp {join*initialize
    (state <s> ^superstate.operator <o>)
    (<o> ^name join ^left <l> ^right <r> ^return-to <return-to>)
-->
    (<s> ^name join ^left <l> ^right <r> ^return-to <return-to>)}

sp {join*base-case
    (state <s> ^name join ^left nil ^superstate <ss> ^return-to <return-to> ^right <r>)
-->
    (<ss> ^<return-to> <r>)}

# TODO: join non-nil case

########################################################################################### avl

sp {avl*initialize
    (state <s> ^superstate.operator <o>)
    (<o> ^name avl ^element <x> ^left <l> ^right <r> ^return-to <return-to>)
-->
    (<s> ^name avl ^element <x> ^left <l> ^right <r> ^return-to <return-to>)}

sp {avl*propose*make-node
    (state <s> ^name avl ^element <x> ^left <l> ^right <r> -^make-node-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name make-node ^element <x> ^left <l> ^right <r> ^return-to make-node-result)}

sp {avl*propose*rebalance
    (state <s> ^name avl ^make-node-result <t> -^rebalance-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name rebalance ^tree <t> ^return-to rebalance-result)}

sp {avl*copy*upward
    (state <s> ^name avl ^superstate <ss> ^return-to <r> ^rebalance-result <a>)
-->
    (<ss> ^<r> <a>)}

############################################################################################ make-node

sp {make-node*initialize
    (state <s> ^superstate.operator <o>)
    (<o> ^name make-node ^element <x> ^left <l> ^right <r> ^return-to <return-to>)
-->
    (<s> ^name make-node ^element <x> ^left <l> ^right <r> ^return-to <return-to>)}

sp {make-node*elaborate*left-height*nil
    (state <s> ^name make-node ^left nil)
-->
    (<s> ^left-height 0)}

sp {make-node*elaborate*left-height*non-nil
    (state <s> ^name make-node ^left.height <h>)
-->
    (<s> ^left-height <h>)}

sp {make-node*elaborate*right-height*nil
    (state <s> ^name make-node ^right nil)
-->
    (<s> ^right-height 0)}

sp {make-node*elaborate*right-height*non-nil
    (state <s> ^name make-node ^right.height <h>)
-->
    (<s> ^right-height <h>)}

sp {make-node*apply
    (state <s> ^name make-node
               ^superstate <ss>
               ^return-to <return-to>
               ^left-height <lheight>
               ^right-height <rheight>
               ^element <x>
               ^left <l>
               ^right <r>)
-->
    (<ss> ^<return-to> <newnode>)
    (<newnode> ^height (+ 1 (max <lheight> <rheight>)) ^element <x> ^left <l> ^right <r>)}

############################################################################################## rebalance

sp {rebalance*initialize
    (state <s> ^superstate.operator <o>)
    (<o> ^name rebalance ^tree <t> ^return-to <r>)
-->
    (<s> ^name rebalance ^tree <t> ^return-to <r>)}

sp {rebalance*elaborate*left-height*nil
    (state <s> ^name rebalance ^tree.left nil)
-->
    (<s> ^left-height 0)}

sp {rebalance*elaborate*left-height*non-nil
    (state <s> ^name rebalance ^tree.left.height <h>)
-->
    (<s> ^left-height <h>)}

sp {rebalance*elaborate*right-height*nil
    (state <s> ^name rebalance ^tree.right nil)
-->
    (<s> ^right-height 0)}

sp {rebalance*elaborate*right-height*non-nil
    (state <s> ^name rebalance ^tree.right.height <h>)
-->
    (<s> ^right-height <h>)}

sp {rebalance*elaborate*slope
    (state <s> ^left-height <lheight> ^right-height <rheight>)
-->
    (<s> ^slope (- <lheight> <rheight>))}

# TODO
#sp {rebalance*propose*shift-left
#    (state <s> ^slope -2 ^tree <t> -^shift-result)
#-->
#    (<s> ^operator <o> +)
#    (<o> ^name shift-left ^tree <t> ^return-to shift-result)}

# TODO 
#sp {rebalance*propose*shift-right
#    (state <s> ^slope 2 ^tree <t> -^shift-result)
#-->
#    (<s> ^operator <o> +)
#    (<o> ^name shift-right ^tree <t> ^return-to shift-result)}

sp {rebalance*slope-okay
    (state <s> ^slope << -1 0 1 >> ^superstate <ss> ^return-to <r> ^tree <a>)
-->
    (<ss> ^<r> <a>)}

# TODO
#sp {rebalance*shift-done*copy-upward
#    (state <s> ^superstate <ss> ^return-to <r> ^shift-result <a>)
#-->
#    (<ss> ^<r> <a>)}

# TODO: shift-left
# TODO: shift-right
# TODO: roll-left
# TODO: roll-right
# TODO: last
# TODO: init
