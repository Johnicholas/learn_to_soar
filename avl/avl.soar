# This is an attempt at implementing AVL trees in Soar.
# It is based on avltree.pure, but probably bugs were introduced by Johnicholas
#
# ASSUMPTIONS
#
# less-than is an operator, provided by the client, that compares two elements
#
# PUBLIC 
#
# empty-set builds a new empty set
#
# insert takes an element <to-insert> and a set and builds a new set that includes <to-insert>.
# if <to-insert> or something that (according to less-than) compares equal to <to-insert> is already in the set,
# then the set doesn't change.
#
# delete takes an element <to-delete> and a set and builds a new set without <to-delete>
# 
# lookup takes an element <key> and a set and returns either nothing,
# or ^just <x>, where <x> is the element from the set that compares equal to the key
#
# PRIVATE
#
# makenode - a smart constructor that takes a node, a left tree and a right tree,
# and allocates a new node making sure to set its height field correctly.
#
# height - the height of an empty tree is zero; other trees have a height field that should be trusted.
#
# slope - the slope of an empty tree is zero;
# otherwise its the difference between heights of the left and right subtrees
#
# avl - a smart constructor that takes a node, a left tree and a right tree,
# and builds a new tree satisfying the AVL invariant.
#
# rebalance - takes a slightly-unbalanced tree and fixes it, by delegating to shiftleft or shiftright,
# or returning the input if it isn't actually unbalanced.
#
# rollleft - an operator that takes apart a right-leaning tree and builds a more-balanced tree
#
# rollright - an operator that takes apart a left-leaning tree and builds a more-balanced tree
#
# shiftleft - an operator used by rebalance and delegating to rollleft and rollright to fix up a nearly-balanced tree
#
# shiftright - an operator used by rebalance and delegating to rollright to fix up a nearly-balanced tree
#
# join - an operator that takes a left avl tree and a right avl tree and builds a combination tree
#
# last - an operator used (by join) to find the last of an avl tree; you must call it with an element and a tree,
# it will return the element you called it with, or the last of the avl tree.
#
# init - an operator used (by join) to find the initial segment of an avl tree; all but the last element.
#
# REPRESENTATION
#
# An avl set is always ^Avl <x>, where <x> is a tree
# A tree is either nil or a node.
# Nodes are augmented with ^height <h> where <h> is a number, ^element <e>, where <e> is whatever the client
# is storing in this set, and both ^left <l> and ^right <r> where <l> and <r> are trees.
#
# The invariant maintained is simple: the heights are correct, and the subtrees differ in height by no more than 1.

sp {empty-set*apply
    (state <s> ^operator <o>)
    (<o> ^name empty-set ^return-to <return-to>)
-->
    (<s> ^<return-to>.Avl nil)}

######################################### delete

sp {delete*initialize*initially
    (state <s> ^superstate.operator <o>)
    (<o> ^name delete ^element <e> ^set.Avl <t> ^return-to <r>)
-->
    (<s> ^name delete ^element <e> ^tree <t> ^return-to <r>)}

sp {delete*initialize*recursively
    (state <s> ^superstate.operator <o>)
    (<o> ^name delete ^element <e> ^tree <t> ^return-to <r>)
-->
    (<s> ^name delete ^element <e> ^tree <t> ^return-to <r>)}

sp {delete*apply*nil
    (state <s> ^name delete ^tree nil ^superstate <ss> ^return-to <r>)
-->
    (<ss> ^<r>.Avl nil)}


sp {delete*propose*check-left
    (state <s> ^name delete ^tree.element <x> ^element <y> -^check-left-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <x> ^right <y> ^return-to check-left-result)}

sp {delete*propose*check-right
    (state <s> ^name delete ^check-left-result false ^tree.element <x> ^element <y> -^check-right-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <y> ^right <x> ^return-to check-right-result)}

sp {delete*propose*recurse-left
    (state <s> ^name delete ^check-left-result true ^tree.left <t> ^element <y> -^recurse-left-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name delete ^tree <t> ^element <y> ^return-to recurse-left-result)}

#sp {delete*recurse-left-done*propose*avl
#    (state <s> ^name delete ^superstate <ss> ^return-to <r> ^recurse-left-result <a>)
#-->
# TODO

sp {delete*propose*recurse-right
    (state <s> ^name delete ^check-right-result true ^tree.right <t> ^element <y> -^recurse-right-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name delete ^tree <t> ^element <y> ^return-to recurse-right-result)}

#sp {delete*recurse-right-done*propose*avl
#    (state <s> ^name delete ^recurse-right-result <a>)
#-->
# TODO


sp {delete*found-here*propose*join
    (state <s> ^name delete
               ^check-left-result false
               ^check-right-result false
               ^tree <t>
              -^join-result)
    (<t> ^left <l> ^right <r>)
-->
    (<s> ^operator <o> +)
    (<o> ^name join ^left <l> ^right <r> ^return-to join-result)}

sp {delete*copy*join-result*up
    (state <s> ^name delete ^superstate <ss> ^return-to <r> ^join-result <a>)
-->
    (<ss> ^<r>.Avl <a>)}

##################### lookup


sp {lookup*initialize*initially
    (state <s> ^superstate.operator <o>)
    (<o> ^name lookup ^element <e> ^set.Avl <t> ^return-to <r>)
-->
    (<s> ^name lookup ^element <e> ^tree <t> ^return-to <r>)}

sp {lookup*initialize*recursively
    (state <s> ^superstate.operator <o>)
    (<o> ^name lookup ^element <e> ^tree <t> ^return-to <r>)
-->
    (<s> ^name lookup ^element <e> ^tree <t> ^return-to <r>)}

sp {lookup*apply*nil
    (state <s> ^name lookup ^tree nil ^superstate <ss> ^return-to <r>)
-->
    (<ss> ^<r> nothing)}

sp {lookup*propose*check-left
    (state <s> ^name lookup ^tree.element <x> ^element <y> -^check-left-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <x> ^right <y> ^return-to check-left-result)}

sp {lookup*propose*check-right
    (state <s> ^name lookup ^check-left-result false ^tree.element <x> ^element <y> -^check-right-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name less-than ^left <y> ^right <x> ^return-to check-right-result)}

sp {lookup*propose*recurse-left
    (state <s> ^name lookup ^check-left-result true ^tree.left <t> ^element <y> -^recursion-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name lookup ^tree <t> ^element <y> ^return-to recursion-result)}

sp {lookup*apply*recursion-done
    (state <s> ^name lookup ^superstate <ss> ^return-to <r> ^recursion-result <a>)
-->
    (<ss> ^<r> <a>)}

sp {lookup*propose*recurse-right
    (state <s> ^name lookup ^check-right-result true ^tree.right <t> ^element <y> -^recursion-result)
-->
    (<s> ^operator <o> +)
    (<o> ^name lookup ^tree <t> ^element <y> ^return-to recursion-result)}

sp {lookup*apply*found-here
    (state <s> ^name lookup ^check-left-result false ^check-right-result false
               ^superstate <ss> ^return-to <r> ^tree.element <x>)
-->
    (<ss> ^<r>.just <x>)}

##################################### insert

sp {insert*apply*nil
    (state <s> ^operator <o>)
    (<o> ^name insert ^element <e> ^set.Avl nil ^return-to <r>)
-->
    (<s> ^<r>.Avl <tree>)
    (<tree> ^height 1 ^element <e> ^left nil ^right nil)}


################################ join 

sp {join*initialize
    (state <s> ^superstate.operator <o>)
    (<o> ^name join ^left <l> ^right <r> ^return-to <return-to>)
-->
    (<s> ^name join ^left <l> ^right <r> ^return-to <return-to>)}

sp {join*base-case
    (state <s> ^name join ^left nil ^superstate <ss> ^return-to <return-to> ^right <r>)
-->
    (<ss> ^<return-to> <r>)}

# TODO: last recursive case
